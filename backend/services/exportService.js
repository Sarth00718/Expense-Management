import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import * as XLSX from 'xlsx';
import Expense from '../models/Expense.js';
import User from '../models/User.js';
import Company from '../models/Company.js';

/**
 * Generate PDF report for expenses
 */
export const generatePDFReport = async (expenses, filters, user, company) => {
  const doc = new jsPDF();
  
  // Add title
  doc.setFontSize(18);
  doc.setTextColor(10, 25, 41); // Dark blue
  doc.text('Expense Report', 14, 20);
  
  // Add company info
  doc.setFontSize(10);
  doc.setTextColor(100);
  doc.text(`Company: ${company.name}`, 14, 30);
  doc.text(`Generated by: ${user.firstName} ${user.lastName}`, 14, 36);
  doc.text(`Date: ${new Date().toLocaleDateString()}`, 14, 42);
  
  // Add filters info
  if (filters.startDate || filters.endDate || filters.category || filters.status) {
    doc.text('Filters Applied:', 14, 52);
    let yPos = 58;
    
    if (filters.startDate) {
      doc.text(`Start Date: ${new Date(filters.startDate).toLocaleDateString()}`, 14, yPos);
      yPos += 6;
    }
    if (filters.endDate) {
      doc.text(`End Date: ${new Date(filters.endDate).toLocaleDateString()}`, 14, yPos);
      yPos += 6;
    }
    if (filters.category) {
      doc.text(`Category: ${filters.category}`, 14, yPos);
      yPos += 6;
    }
    if (filters.status) {
      doc.text(`Status: ${filters.status}`, 14, yPos);
      yPos += 6;
    }
  }
  
  // Prepare table data
  const tableData = expenses.map(expense => [
    new Date(expense.date).toLocaleDateString(),
    expense.employeeName || 'N/A',
    expense.category,
    expense.description.substring(0, 30) + (expense.description.length > 30 ? '...' : ''),
    `${expense.amount.toFixed(2)} ${expense.currency}`,
    `${expense.convertedAmount.toFixed(2)} ${company.baseCurrency}`,
    expense.status
  ]);
  
  // Calculate totals
  const totalAmount = expenses.reduce((sum, exp) => sum + exp.convertedAmount, 0);
  
  // Add table
  doc.autoTable({
    startY: filters.startDate || filters.endDate || filters.category || filters.status ? 70 : 52,
    head: [['Date', 'Employee', 'Category', 'Description', 'Amount', `Amount (${company.baseCurrency})`, 'Status']],
    body: tableData,
    theme: 'striped',
    headStyles: {
      fillColor: [10, 25, 41],
      textColor: [255, 255, 255],
      fontSize: 9
    },
    bodyStyles: {
      fontSize: 8
    },
    columnStyles: {
      3: { cellWidth: 40 }
    },
    margin: { top: 10 }
  });
  
  // Add summary
  const finalY = doc.lastAutoTable.finalY || 70;
  doc.setFontSize(12);
  doc.setTextColor(10, 25, 41);
  doc.text(`Total Expenses: ${expenses.length}`, 14, finalY + 10);
  doc.text(`Total Amount: ${totalAmount.toFixed(2)} ${company.baseCurrency}`, 14, finalY + 18);
  
  // Add breakdown by status
  const statusBreakdown = expenses.reduce((acc, exp) => {
    acc[exp.status] = (acc[exp.status] || 0) + 1;
    return acc;
  }, {});
  
  doc.setFontSize(10);
  let summaryY = finalY + 28;
  doc.text('Status Breakdown:', 14, summaryY);
  summaryY += 6;
  
  Object.entries(statusBreakdown).forEach(([status, count]) => {
    doc.text(`${status}: ${count}`, 20, summaryY);
    summaryY += 6;
  });
  
  return doc.output('arraybuffer');
};

/**
 * Generate Excel report for expenses
 */
export const generateExcelReport = async (expenses, filters, user, company) => {
  // Create workbook
  const workbook = XLSX.utils.book_new();
  
  // Prepare expense data
  const expenseData = expenses.map(expense => ({
    'Date': new Date(expense.date).toLocaleDateString(),
    'Employee': expense.employeeName || 'N/A',
    'Category': expense.category,
    'Description': expense.description,
    'Amount': expense.amount,
    'Currency': expense.currency,
    [`Amount (${company.baseCurrency})`]: expense.convertedAmount,
    'Status': expense.status,
    'Vendor': expense.ocrData?.vendor || 'N/A',
    'Created At': new Date(expense.createdAt).toLocaleDateString()
  }));
  
  // Create expenses worksheet
  const expensesSheet = XLSX.utils.json_to_sheet(expenseData);
  
  // Set column widths
  expensesSheet['!cols'] = [
    { wch: 12 }, // Date
    { wch: 20 }, // Employee
    { wch: 15 }, // Category
    { wch: 40 }, // Description
    { wch: 12 }, // Amount
    { wch: 10 }, // Currency
    { wch: 15 }, // Amount (Base)
    { wch: 12 }, // Status
    { wch: 20 }, // Vendor
    { wch: 12 }  // Created At
  ];
  
  XLSX.utils.book_append_sheet(workbook, expensesSheet, 'Expenses');
  
  // Create summary worksheet
  const totalAmount = expenses.reduce((sum, exp) => sum + exp.convertedAmount, 0);
  const avgAmount = expenses.length > 0 ? totalAmount / expenses.length : 0;
  
  const statusBreakdown = expenses.reduce((acc, exp) => {
    acc[exp.status] = (acc[exp.status] || 0) + 1;
    return acc;
  }, {});
  
  const categoryBreakdown = expenses.reduce((acc, exp) => {
    if (!acc[exp.category]) {
      acc[exp.category] = { count: 0, total: 0 };
    }
    acc[exp.category].count += 1;
    acc[exp.category].total += exp.convertedAmount;
    return acc;
  }, {});
  
  const summaryData = [
    { 'Metric': 'Total Expenses', 'Value': expenses.length },
    { 'Metric': `Total Amount (${company.baseCurrency})`, 'Value': totalAmount.toFixed(2) },
    { 'Metric': `Average Amount (${company.baseCurrency})`, 'Value': avgAmount.toFixed(2) },
    { 'Metric': '', 'Value': '' },
    { 'Metric': 'Status Breakdown', 'Value': '' },
    ...Object.entries(statusBreakdown).map(([status, count]) => ({
      'Metric': `  ${status}`,
      'Value': count
    })),
    { 'Metric': '', 'Value': '' },
    { 'Metric': 'Category Breakdown', 'Value': '' },
    ...Object.entries(categoryBreakdown).map(([category, data]) => ({
      'Metric': `  ${category}`,
      'Value': `${data.count} expenses, ${data.total.toFixed(2)} ${company.baseCurrency}`
    }))
  ];
  
  // Add filter information
  if (filters.startDate || filters.endDate || filters.category || filters.status) {
    summaryData.unshift({ 'Metric': '', 'Value': '' });
    summaryData.unshift({ 'Metric': 'Filters Applied', 'Value': '' });
    
    if (filters.startDate) {
      summaryData.splice(2, 0, { 
        'Metric': '  Start Date', 
        'Value': new Date(filters.startDate).toLocaleDateString() 
      });
    }
    if (filters.endDate) {
      summaryData.splice(filters.startDate ? 3 : 2, 0, { 
        'Metric': '  End Date', 
        'Value': new Date(filters.endDate).toLocaleDateString() 
      });
    }
    if (filters.category) {
      summaryData.splice(2 + (filters.startDate ? 1 : 0) + (filters.endDate ? 1 : 0), 0, { 
        'Metric': '  Category', 
        'Value': filters.category 
      });
    }
    if (filters.status) {
      summaryData.splice(2 + (filters.startDate ? 1 : 0) + (filters.endDate ? 1 : 0) + (filters.category ? 1 : 0), 0, { 
        'Metric': '  Status', 
        'Value': filters.status 
      });
    }
  }
  
  // Add report metadata at the top
  summaryData.unshift({ 'Metric': '', 'Value': '' });
  summaryData.unshift({ 'Metric': 'Generated Date', 'Value': new Date().toLocaleDateString() });
  summaryData.unshift({ 'Metric': 'Generated By', 'Value': `${user.firstName} ${user.lastName}` });
  summaryData.unshift({ 'Metric': 'Company', 'Value': company.name });
  summaryData.unshift({ 'Metric': 'Report Type', 'Value': 'Expense Report' });
  
  const summarySheet = XLSX.utils.json_to_sheet(summaryData);
  summarySheet['!cols'] = [
    { wch: 30 },
    { wch: 40 }
  ];
  
  XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');
  
  // Generate buffer
  const excelBuffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
  
  return excelBuffer;
};

/**
 * Fetch and prepare expense data for export
 */
export const fetchExpensesForExport = async (user, filters) => {
  let matchQuery = { companyId: user.companyId };
  
  // Role-based filtering
  if (user.role === 'employee') {
    matchQuery.employeeId = user._id;
  } else if (user.role === 'manager') {
    const teamMembers = await User.find({ 
      managerId: user._id,
      companyId: user.companyId,
      isActive: true
    }).select('_id');
    
    const teamMemberIds = teamMembers.map(member => member._id);
    matchQuery.employeeId = { $in: [...teamMemberIds, user._id] };
  }
  
  // Apply filters
  if (filters.startDate || filters.endDate) {
    matchQuery.date = {};
    if (filters.startDate) {
      matchQuery.date.$gte = new Date(filters.startDate);
    }
    if (filters.endDate) {
      matchQuery.date.$lte = new Date(filters.endDate);
    }
  }
  
  if (filters.category) {
    matchQuery.category = filters.category;
  }
  
  if (filters.status) {
    matchQuery.status = filters.status;
  }
  
  // Fetch expenses with employee information
  const expenses = await Expense.find(matchQuery)
    .populate('employeeId', 'firstName lastName email')
    .sort({ date: -1 })
    .lean();
  
  // Format expenses with employee name
  const formattedExpenses = expenses.map(expense => ({
    ...expense,
    employeeName: expense.employeeId 
      ? `${expense.employeeId.firstName} ${expense.employeeId.lastName}`
      : 'Unknown'
  }));
  
  return formattedExpenses;
};

